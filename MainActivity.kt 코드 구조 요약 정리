MainActivity.kt 코드 구조 요약 설명을 정리

코드 초반부에는 서버와 주고받는 데이터 구조를 정의하는 DTO(Data Transfer Object) 가 선언되어 있다.

data class PillRecognitionResponse(
    val pill_name: String,
    val pill_code: String?,
    val ingredients: List<Ingredient>?,
    val confidence: Double?,
    val color: String?,
    val shape: String?,
    val imprint: String?,
    val warnings: List<String>?
)

이 모델은 서버에서 반환되는 알약 인식 결과를 그대로 매핑하기 위한 구조이며,
신뢰도(confidence), 외형 정보(color, shape), 경고 정보(warnings) 등 머신러닝 기반 인식 결과를 담는 역할을 한다.
이후 등장하는 PillDetail 클래스는 UI에 최적화된 도메인 모델이다.
서버 응답이나 검색 결과 등 데이터의 출처와 상관없이, 결과 화면에서는 항상 동일한 구조로 표시되도록 설계되었다.

data class PillDetail(
    val name: String,
    val efficacy: String,
    val dosage: String,
    val ingredients: String,
    val sideEffects: String,
    val contraindications: String,
    val interactions: String
)

이를 통해 데이터 계층과 화면 계층을 분리하여, 향후 API 확장이나 DB 연동 시에도 UI 수정이 최소화되도록 구성되어 있다. 네트워크 통신은 Retrofit을 사용해 정의되어 있다. PillApiService 인터페이스에서는 알약 이미지를 서버로 전송하는 API를 명확히 선언한다.
@Multipart
@POST("/api/v1/pill/recognize")
suspend fun recognizePill(
    @Part file: MultipartBody.Part
): PillRecognitionResponse

이미지 파일을 multipart 형태로 전송하고, 서버로부터 인식 결과를 받아오는 구조다. ApiClient 객체에서는 에뮬레이터 환경(10.0.2.2)을 기준으로 Retrofit 인스턴스를 생성해 관리한다. 이 네트워크 로직은 곧바로 UI에서 호출되지 않고, Repository 계층을 거쳐 사용된다.

class RetrofitPillRepository : PillRepository {
    override suspend fun recognizePill(imageFile: File): PillRecognitionResponse {
        ...
        return api.recognizePill(part)
    }
}

이 구조를 통해 네트워크 구현체를 교체하거나(Mock, Fake Repository), 테스트 코드 작성 시에도 유연하게 대응할 수 있도록 설계되어 있다 UI 상태 관리는 sealed class PillUiState를 통해 명확하게 표현된다.

sealed class PillUiState {
    object Idle : PillUiState()
    object Loading : PillUiState()
    data class Success(val result: PillRecognitionResponse) : PillUiState()
    data class Error(val message: String) : PillUiState()
}

이를 통해 분석 전 / 분석 중 / 성공 / 실패 상태가 명확히 구분되며, Compose UI는 이 상태 변화에 따라 자동으로 화면을 갱신하게 된다. 이 상태를 실제로 관리하는 주체는 PillRecognitionViewModel이다. ViewModel은 이미지 파일 경로를 받아 서버 분석을 요청하고, 그 결과를 uiState로 노출한다.

fun analyze(photoPath: String) {
    viewModelScope.launch {
        uiState = PillUiState.Loading
        val result = repository.recognizePill(file)
        uiState = PillUiState.Success(result)
    }
}

이 구조는 UI와 비즈니스 로직을 분리하고, Compose 재구성(Recomposition) 시에도 안정적으로 동작하도록 만든 핵심 설계다. MainActivity는 앱의 진입점으로, 앱 실행 시 카메라 권한을 먼저 요청하고, 홈 화면과 카메라 화면 사이의 전환을 제어한다.

var showCamera by remember { mutableStateOf(false) }
if (showCamera) {
    AppRoot(onExitCamera = { showCamera = false })
} else {
    HomeScreen(onClickSearchCamera = { showCamera = true })
}

여기서 MainActivity 자체는 복잡한 UI를 직접 그리지 않고, 상태만 관리한 뒤 실제 화면 구성은 Composable 함수로 위임한다. AppRoot는 내부 네비게이션 역할을 수행하는 핵심 Composable이다. 카메라 → 미리보기 → 결과 화면을 CameraRoute라는 sealed class로 관리한다.

sealed class CameraRoute {
    object Camera : CameraRoute()
    data class Preview(val photoPath: String) : CameraRoute()
    data class Result(val detail: PillDetail) : CameraRoute()
}

이를 통해 Navigation 라이브러리를 사용하지 않고도 단일 화면 흐름을 명확하고 직관적으로 제어하고 있다.
카메라 화면(CameraScreen)에서는 CameraX를 사용해 실시간 프리뷰와 사진 촬영을 처리한다.
촬영 버튼을 누르면 이미지가 파일로 저장되고, 그 경로가 미리보기 화면으로 전달된다.

imageCapture.takePicture(
    outputOptions,
    executor,
    object : ImageCapture.OnImageSavedCallback { ... }
)

사진 미리보기 화면(PhotoPreviewScreen)에서는 촬영된 이미지를 표시하고, 재촬영 / 저장 / 분석하기 버튼을 제공한다. 분석하기 버튼을 누르면 ML Kit 기반 OCR이 먼저 수행된다.

recognizeTextFromBitmap(bitmap) { text ->
    onAnalyzeAndNavigate(text)
}

OCR 결과는 서버 분석 결과와 함께 알약 이름 보조 정보로 활용된다.

결과 화면(PillResultScreen)은 PillDetail 객체를 받아
효능, 용법, 성분, 부작용, 금기, 상호작용 정보를 카드 형태로 정리해 보여준다.
이 화면은 카메라 인식 결과와 검색 결과 모두에서 공통으로 재사용 가능한 구조다.

마지막으로 파일 하단에는 사진 회전 보정(EXIF),
텍스트 인식(ML Kit), 그리고 Compose Preview용 더미 UI 코드가 포함되어 있어
실제 기기와 개발 환경 모두에서 안정적인 동작을 보장한다.

정리하면, 이 MainActivity.kt는 카메라 기반 입력, OCR 전처리, 서버 기반 알약 인식 상태 기반 UI 렌더링 Compose 중심의 단일 흐름 설계를 하나의 파일 안에서 계층적으로 잘 분리해 구현한 구조이다.
